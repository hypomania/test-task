package org.example.testtask.utils;

import org.example.testtask.entity.VulnerabilityScript;
import org.example.testtask.exceptions.CircularDependenciesException;

import java.util.*;

public class VulnerabilityScriptUtil {
    private final HashMap<Integer, VulnerabilityScript> idToScriptMap = new HashMap<>();
    private final HashMap<Integer, Boolean> visitedScripts = new HashMap<>();
    private final LinkedHashSet<Integer> resultOrdering = new LinkedHashSet<>();

    /**
     * Returns the List of Script Ids which can be used to execute scripts in a valid order
     *
     * @param scripts List of VulnerabilityScript objects
     * @return List of Integers in the valid order for the future execution
     * @throws CircularDependenciesException if scripts have circular dependencies
     */
    public List<Integer> generateExecutionPlan(final List<VulnerabilityScript> scripts) throws CircularDependenciesException {
        if (Objects.isNull(scripts)) {
            return Collections.emptyList();
        }
        scripts.forEach(item -> idToScriptMap.put(item.getScriptId(), item));
        scripts.forEach(item -> visitedScripts.put(item.getScriptId(), false));

        for (VulnerabilityScript script : scripts) {
            this.dfs(script);
        }

        return new LinkedList<>(resultOrdering);
    }

    /**
     * Recursive step of dfs algorithm. It should add scriptId that is not yet visited to the result plan
     *
     * @param script Current VulnerabilityScript
     * @throws CircularDependenciesException
     */
    private void dfs(final VulnerabilityScript script) throws CircularDependenciesException {
        int scriptId = script.getScriptId();
        if (visitedScripts.get(scriptId)) {
            return;
        }
        visitedScripts.put(scriptId, true);
        for (Integer itemId : script.getDependencies()) {
            if (visitedScripts.get(itemId) && !resultOrdering.contains(itemId)) {
                throw new CircularDependenciesException("There are circular dependencies", script);
            }
            dfs(idToScriptMap.get(itemId));
        }
        resultOrdering.add(scriptId);
    }
}
