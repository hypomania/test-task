package org.example.testtask.utils;

import org.example.testtask.entity.VulnerabilityScript;
import org.example.testtask.exceptions.CircularDependenciesException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.*;
import java.util.stream.Stream;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class VulnerabilityScriptUtilTest {

    @ParameterizedTest
    @MethodSource("provideLists")
    public void testGenerateExecutionPlan(List<VulnerabilityScript> initial) throws CircularDependenciesException {
        VulnerabilityScriptUtil util = new VulnerabilityScriptUtil();
        List<Integer> result = util.generateExecutionPlan(initial);
        Assertions.assertEquals(true, checkExecutionPlanValidity(initial, result));
    }

    @Test
    public void testGenerateExecutionPlanWithCyclicalDependenciesThrowsException() {
        VulnerabilityScriptUtil util = new VulnerabilityScriptUtil();

        List<VulnerabilityScript> initial = asList(
                new VulnerabilityScript(1, singletonList(2)),
                new VulnerabilityScript(2, singletonList(3)),
                new VulnerabilityScript(3, singletonList(4)),
                new VulnerabilityScript(4, singletonList(5)),
                new VulnerabilityScript(5, singletonList(1))
        );
        Assertions.assertThrows(CircularDependenciesException.class, () -> {
            util.generateExecutionPlan(initial);
        });
    }

    private static Stream<Arguments> provideLists() {
        return Stream.of(
                Arguments.of(asList(
                        new VulnerabilityScript(1, asList(2,3)),
                        new VulnerabilityScript(2, singletonList(5)),
                        new VulnerabilityScript(3, asList(4,5)),
                        new VulnerabilityScript(4, singletonList(5)),
                        new VulnerabilityScript(5, emptyList())
                )),
                Arguments.of(asList(
                        new VulnerabilityScript(1, asList(2,3,4,5)),
                        new VulnerabilityScript(2, asList(3,4,5)),
                        new VulnerabilityScript(3, asList(4,5)),
                        new VulnerabilityScript(4, singletonList(5)),
                        new VulnerabilityScript(5, emptyList())
                )),
                Arguments.of(emptyList())
        );
    }

    private Boolean checkExecutionPlanValidity(List<VulnerabilityScript> initial, List<Integer> plan) {
        HashMap<Integer, VulnerabilityScript> idToScriptMap = new HashMap<>();
        initial.forEach(item->idToScriptMap.put(item.getScriptId(), item));

        HashSet<Integer> executed = new HashSet<>();
        for (Integer scriptId: plan) {
            List<Integer> dependencies = idToScriptMap.get(scriptId).getDependencies();
            if (!dependencies.isEmpty() && dependencies.stream().anyMatch(x -> !executed.contains(x))) {
                return false;
            }
            executed.add(scriptId);
        }
        return true;
    }
}
